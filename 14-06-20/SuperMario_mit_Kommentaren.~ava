import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.event.*;
import java.awt.event.KeyEvent;
import java.util.ArrayList;
import java.util.Hashtable;
import java.awt.font.TextAttribute;
import java.io.*;
import java.awt.image.BufferedImage;
import javax.imageio.*;
import java.awt.Image;
import javax.swing.JPanel;
import javax.swing.ImageIcon;

/**
 *
 * Beschreibung
 *
 * @version 1.3 vom 10.06.2020
 * @Marc St�we, Lars von Bandel, Niklas Goldschmidt und Dominik Schulz
 *
 * Bekannte Bugs/Baustellen:
  * Springen resettet sich nicht vern�nftig, Fliegen m�glich (muss noch umgecodet werden, gerade sehr unelegant gel�st)
  * groundpanel bewegt sich nicht mit <- bewegt sich mit, ist größer als das Fenster
  * Marios Boxinteraktionen sind nicht fertig
  * Programmieren eines Gegners und weiterer Spielelemente
 */

public class SuperMario_mit_Kommentaren extends JApplet {
  //Benutzte Objekte (Charakter, Box, PowerUp, Boden und ein Array zum Speichern der zu bewegenden Panels wird definiert
  // Anfang Attribute
  //JPanels werden definiert
  private JPanel marioCharacter = new JPanel(null, true); 
  private JPanel eventBox = new JPanel(null, true); 
  private JPanel box = new JPanel(null, true);    
  private JPanel powerUP = new JPanel(null, true); 
  private JPanel ground = new JPanel(null, true);
  private JPanel opponent = new JPanel(null, true);
  private JPanel flag = new JPanel(null, true);
  
  //ArrayLists werden definiert
  ArrayList<JPanel> panels = new ArrayList<JPanel>(); 
  
  //Definition zus�tzlicher Objekte
  private Timer timer_update = new Timer(1000, null);
  private JButton bStart = new JButton();
  
  //Essentielle globale Bewegungsvariablen f�r Mario
  int jumpSpeed = 2;
  int moveSpeed = 2;
  int maxJumpHeight = 260;
  int currentJumpHeight = 0;
  
  //Abfragevariablen f�r Marios Aktionen
  boolean jumping = false;
  boolean moveRight = false;
  boolean moveLeft = false;
  boolean flagtouched = false;
  boolean sneaking = false;
  boolean sneak_confirm = true;
  private Timer opponent_jump = new Timer(1000, null);
  private Timer opponentleft = new Timer(1000, null);
  private JTextField text_fail = new JTextField();
  private Timer chek_for_finishline = new Timer(1000, null);

  //Abfragevariablen fuer den Gegner
  int maxJumpHeightOpponent = 110;
  int currentJumpHeightOpponent = 0;
  int opponentheight = 50;
  int opponentwidth = 50;
  boolean opponentjump = false;
  boolean opponentdie = false;
  boolean nottouched = true;
  
  //BufferedImages werden definiert
  private BufferedImage boxImage;     
  private BufferedImage eventBoxImage;
  private Image testImage;   
  
  //Graphics werden definiert
  private Graphics BoxGraphics;       
  private Graphics eventBoxGraphics;  
  private JTextField text_win = new JTextField();
  // Ende Attribute


  public void init() {
    Container cp = getContentPane();
    cp.setLayout(null);
    cp.setSize(1080, 720);
    cp.setBounds(0, 0, 957, 691);
    panels.add(eventBox);
    panels.add(box);
    panels.add(powerUP);
    panels.add(ground);
    panels.add(flag);
    powerUP.setVisible(false);
    KeyboardFocusManager.getCurrentKeyboardFocusManager().addKeyEventDispatcher(new KeyEventDispatcher() { // Event f�r die Abfrage der Tasteneingaben wird definiert

      @Override
      public boolean dispatchKeyEvent(KeyEvent ke) {
        switch (ke.getID()) {
          case KeyEvent.KEY_PRESSED: // sollte irgendeine Taste heruntergedr�ckt werden, wird folgender Code abgefragt
            if (ke.getKeyCode() == KeyEvent.VK_SPACE) { // Wenn die heruntergedr�ckte Taste die Leertaste ist
              if (currentJumpHeight == 0){
              jumping = true;  
              }
              if (contactwithbox_top()) {
                powerUP.setVisible(true);
            }
          }
            if (ke.getKeyCode() == KeyEvent.VK_D) {
              moveSpeed = -2;
              moveRight = true; // folgender Befehl wird ausgef�hrt, sollte Taste 'D' gedr�ckt werden
            // moveSidewards(movespeed);
          }
            if (ke.getKeyCode() == KeyEvent.VK_A) { // folgender Befehl wird ausgef�hrt, sollte Taste 'A' gedr�ckt werden
              moveSpeed = 2;
              moveLeft = true;
            // moveSidewards(movespeed);
          }
            if (ke.getKeyCode() == KeyEvent.VK_SHIFT) {
              sneaking = true;
            } // end of if
          break;

          case KeyEvent.KEY_RELEASED: // Folgendes passiert, sollte eine Taste losgelassen werden
            if (ke.getKeyCode() == KeyEvent.VK_D) {
              moveRight = false;
          }
            if (ke.getKeyCode() == KeyEvent.VK_A) {
              moveLeft = false;
          }
            if (ke.getKeyCode() == KeyEvent.VK_SHIFT) {
              sneaking = false;
              marioCharacter.setLocation(marioCharacter.getX(), marioCharacter.getY() - 30);
              marioCharacter.setSize(marioCharacter.getWidth(), 100);
              sneak_confirm = true;
            } // end of if
          break;
        }
        return false;
      }
    });
    // Anfang Komponenten

    marioCharacter.setBounds(230, 350, 32, 64);
    marioCharacter.setOpaque(true);
    marioCharacter.setBackground(Color.RED);

    cp.add(marioCharacter);
    eventBox.setBounds(230, 450, 32, 32);
    eventBox.setOpaque(false);
    cp.add(eventBox);
    box.setBounds(262, 450, 32, 32);
    box.setOpaque(false);
    cp.add(box);
    powerUP.setBounds(eventBox.getX(), eventBox.getY() - eventBox.getHeight(), 50, 50);
    powerUP.setOpaque(true);
    powerUP.setBackground(Color.CYAN);
    cp.add(powerUP);
    timer_update.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent evt) {
        timer_update_ActionPerformed(evt);
      }
    });
    timer_update.setRepeats(true);
    timer_update.setInitialDelay(0);
    bStart.setBounds(1172, 7, 75, 25);
    bStart.setText("Start");
    bStart.setMargin(new Insets(2, 2, 2, 2));
    bStart.addActionListener(new ActionListener() {
      public void actionPerformed(ActionEvent evt) {
        bStart_ActionPerformed(evt);
      }
    });
    cp.add(bStart);
    timer_update.setDelay(1);
    ground.setBounds(0, 630, 5000, 55);
    ground.setOpaque(true);
    ground.setBackground(Color.GREEN);
    cp.add(ground);
    opponent.setBounds(1500, 575, opponentwidth, opponentheight);
    opponent.setOpaque(true);
    opponent.setBackground(Color.MAGENTA);
    cp.add(opponent);
    opponent_jump.addActionListener(new ActionListener() { 
      public void actionPerformed(ActionEvent evt) { 
        opponent_jump_ActionPerformed(evt);
      }
    });
    opponent_jump.setRepeats(true);
    opponent_jump.setInitialDelay(0);
    opponent_jump.setDelay(200);
    opponentleft.addActionListener(new ActionListener() { 
      public void actionPerformed(ActionEvent evt) { 
        opponentleft_ActionPerformed(evt);
      }
    });
    opponentleft.setRepeats(true);
    opponentleft.setInitialDelay(0);
    opponentleft.setDelay(10);
    text_fail.setBounds(400, 104, 518, 68);
    text_fail.setEditable(false);
    text_fail.setText("I am sorry but you failed");
    text_fail.setBackground(Color.RED);
    text_fail.setVisible(false);
    Hashtable<TextAttribute, Object> text_fail_map = new Hashtable<TextAttribute, Object>();
    text_fail_map.put(TextAttribute.FAMILY, "Dialog");
    text_fail_map.put(TextAttribute.SIZE, new Integer(48));
    text_fail_map.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
    text_fail.setFont(new Font(text_fail_map));
    text_fail.setForeground(Color.WHITE);
    cp.add(text_fail);
    chek_for_finishline.addActionListener(new ActionListener() { 
      public void actionPerformed(ActionEvent evt) { 
        chek_for_finishline_ActionPerformed(evt);
      }
    });
    chek_for_finishline.setRepeats(true);
    chek_for_finishline.setInitialDelay(0);
    chek_for_finishline.setDelay(1);
    flag.setBounds(493, 365, 20, 20);
    flag.setOpaque(true);
    flag.setBackground(new Color(0xFFAFAF));
    cp.add(flag);
    text_win.setBounds(300, 104, 690, 68);
    text_win.setEditable(false);
    text_win.setText("Congratulations! Goal achieved!");
    text_win.setBackground(Color.GREEN);
    text_win.setVisible(false);
    Hashtable<TextAttribute, Object> text_win_map = new Hashtable<TextAttribute, Object>();
    text_win_map.put(TextAttribute.FAMILY, "Dialog");
    text_win_map.put(TextAttribute.SIZE, new Integer(48));
    text_win_map.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
    text_win.setFont(new Font(text_win_map));
    text_win.setForeground(Color.WHITE);
    cp.add(text_win);
    // Ende Komponenten
    loadBuffedImages();
  } // end of init
    
  //Methode f�r Bewegungen wird erstellt
  public void move(int a) {
    //wenn Mario nach links oder rechts geht, verschiebt sich der Hintergrund / die Panels passend
    if (moveRight == true || moveLeft == true) {
      for (int i = 0; i < panels.size(); i++) {
        JPanel panel = (JPanel) panels.toArray()[i];
        panel.setLocation(panel.getX() + moveSpeed, panel.getY());
      }
    }
    // Beim Springen wird Marios Y-Koordinate verschoben
    if (jumping == true && currentJumpHeight <= maxJumpHeight) {
      marioCharacter.setLocation(marioCharacter.getX(), (marioCharacter.getY() - jumpSpeed));
      currentJumpHeight = currentJumpHeight + jumpSpeed;
    }
    if (sneaking == true && sneak_confirm == true) {
      marioCharacter.setSize(marioCharacter.getWidth(), 70);
      marioCharacter.setLocation(marioCharacter.getX(), marioCharacter.getY() + 30);
      sneak_confirm = false;
    } // end of if 
  }

  // Anfang Methoden
  public void timer_update_ActionPerformed(ActionEvent evt) {
    // Methoden zu Bewegung und die Schwerkraft werden bei jedem Tick des Timers (jede Millisekunde) abgerufen
    this.move(moveSpeed);
    this.variablereset();
    this.opponetcontactleft();
    this.opponentjump();
    this.gravity();
    this.touched();
    this.opponentdie();
    this.paintLabels();
  } // end of timer_update_ActionPerformed

  public void bStart_ActionPerformed(ActionEvent evt) {
    // Updatetimer wird gestartet
    timer_update.start();
    //opponent_jump wird gestartet
    opponent_jump.start();    //Alle 200ms wird Math.random ausgef?hrt. Wenn dabei 0 rauskommt, springt der Gegner
    //opponentleft wird gestartet
    opponentleft.start();     //Dadurch bewegt sich der Gegner jede 10ms um -2 ausser einer der Sonderf?lle trift ein
    //check_for_finishline wird gestertet
    chek_for_finishline.start();   //Jede ms wird kontrolliert ob Mario im Ziel angekommen ist
  }

  public void variablereset() {
    // Wenn Mario bei seiner maximalen Sprungh�he angekommen ist, wird es auf nicht mehr springend gesetzt, damit die Schwerkraft wieder greift
    if (currentJumpHeight == maxJumpHeight) {
      currentJumpHeight = 1;
      jumping = false;
    } // end of if
  }

  public void gravity() {
    // Sollte Mario nicht im Sprung sein oder auf dem Boden stehen, wird er nach unten verschoben, bis er den Boden ber�hrt
    if (jumping == false && this.contactwithground_top() == false && this.contactwithopponent() != true) {
      /*if (contactwithbox_top() == false) {
        
      }       */
      marioCharacter.setLocation(marioCharacter.getX(), marioCharacter.getY() + jumpSpeed);
      if (this.contactwithground_top() == true){
        currentJumpHeight = 0;
      }
    } // end of if
    if (opponentjump == false && this.opponentcontactwithground() == false) {     //Wenn der Gegner nicht Springt und nicht den Boden ber?hrt,
      opponent.setLocation(opponent.getX(), opponent.getY() + jumpSpeed/2);         //dann f?llt er zur?ck auf den Boden
    } // end of if
  }
  //Wenn Mario den Boden ber�hrt (Marios Y + H�he = Y des Bodes), gibt die Methode true aus, um die Schwerkraft zu stoppen
  public boolean contactwithground_top() {
    if ((marioCharacter.getY() + marioCharacter.getHeight()) == ground.getY()) {
      return true;
    } else {
      return false;
    } 
  }
  
  public boolean contactwithopponent(){
    if (marioCharacter.getBounds().intersects(opponent.getBounds())){
      return true;
    } else {
      return false;
    }
  }
  
  public boolean opponentcontactwithground(){
     if ((opponent.getY() + opponent.getHeight()) == ground.getY()){     //Wenn der Gegner den Boden ber?hrt,
      return true;                                                       //wird zur?ckgegeben, dass er das tut
      } 
     else{
      return false;                                                      //oder es wird zur?ckgegeben, dass er den Boden nicht ber?hrt.
     }        
    }
  public boolean opponetcontactleft(){
    if (opponent.getX() <= -opponent.getWidth()){          //Wenn der Gegner aus dem Bild gelaufen ist,
      return true;                                         //wird dies zur?ckgegeben
      }
    else{
      return false;                                       //oder zur?ckgegeben, dass er nicht aus dem Bild gelaufen ist.
      }
    }
  
  //Noch nicht integriert
  public boolean contactwithbox_top() {
    if (marioCharacter.getY() - marioCharacter.getHeight() <= eventBox.getY()
        && (marioCharacter.getX() >= eventBox.getX() && marioCharacter.getX() <= eventBox.getX() + 50)) {
      return true;
    } else {
      return false;
    } 
  }
  public boolean contactwithbox_bottom() {
    if (marioCharacter.getY()<= eventBox.getY() - eventBox.getHeight()
        && (marioCharacter.getX() >= eventBox.getX() && marioCharacter.getX() <= eventBox.getX() + 50)) {
      return true;
    } else {
      return false;
    } 
  }
  
  public void opponent_jump_ActionPerformed(ActionEvent evt) {
    int random;
    random = (int) (Math.random() * 10);                      //Die Zufallszahll wird ausgelost
    switch(random){                                           //Switch mit der Zufallszahl
      case 0:                                                 //Wenn die Zufallszahl 0 ist trift der case ein, dass der Gegner springt
        opponentjump = true;  
      }
  
  } // end of opponent_jump_ActionPerformed
  
  public void opponentjump() {
    if (opponentjump == true && currentJumpHeightOpponent <= maxJumpHeightOpponent) {      //Wenn der Gegner springen soll und die maximale Springh?he noch nicht erreicht ist, springt er jede ms um 2 Einheiten nach oben
      opponent.setLocation(opponent.getX(), opponent.getY() - jumpSpeed/2);           //Y-Koordinate um jumpSpeed erh?hen
      currentJumpHeightOpponent += jumpSpeed/2;                                       //currentJumpHeightOpponent wird um jumpSpeed erh?ht
      if (currentJumpHeightOpponent == maxJumpHeightOpponent) {                     //Wenn currentJumpHeightOpponent gleich der maximalen Springh?he ist,
        opponentjump = false;                                                       //soll der Gegner nicht mehr springen
        currentJumpHeightOpponent = 0;                                              //und die Sprungh?he wird auf 0 zur?ckgesetzt
        } //end of if
    } // end of if
  }
  
  public void opponentleft_ActionPerformed(ActionEvent evt) {
    if (opponetcontactleft() != true && moveLeft != true) {               //Wenn der Gegner nicht links rausgeleufen und Mario nicht nach links l?uft
      if (opponent.getX() - marioCharacter.getX() >= 1200) {              //Wenn dann auch noch der Abstand zwischen dem Gegnjer und Mario gr??er als 1200 einheiten ist,
        opponent.setLocation(opponent.getX() -100, opponent.getY());      //wird l?uft der Gegner mit 100 Einheiten pro 10ms richtung Mario, bis dieser n?her als 1200 einheiten ist
      } // end of if
      else {
        opponent.setLocation(opponent.getX() -1, opponent.getY());        //sont l?uft der gegner alle 10ms um 2 Einheiten in Richtung des Gegners
      } // end of if-else
    } // end of if
    if (moveLeft == true && moveRight != true) {                         //Falls jedoch Mario nach links l?uft,
      opponent.setLocation(opponent.getX() +10, opponent.getY());        //l?uft der Gegner langsamer
    } // end of if
    if (moveRight == true && moveLeft != true) {                         //Falls jedoch MArio nach rechts l?uft,
      opponent.setLocation(opponent.getX() -5, opponent.getY());         //l?uft der Gegner schneller
    } // end of if
    if (opponetcontactleft() == true) {                                  //Falls der Gegner links aus dem Bild l?uft,
      opponent.setLocation(opponent.getX() + 1500, opponent.getY());     //wird er nach rechts ausserhalb des Bildes gesetzt und l?uft dann wieder nach links weiter
    } // end of if
  } // end of opponentleft_ActionPerformed
  
  public void touched(){
    if (marioCharacter.getBounds().intersects(opponent.getBounds())){
      if (marioCharacter.getBounds().contains(opponent.getBounds().x, opponent.getBounds().y) && marioCharacter.getBounds().contains(opponent.getBounds().x + 5, opponent.getBounds().y) || (marioCharacter.getBounds().contains(opponent.getBounds().x + opponent.getBounds().width, opponent.getBounds().y) && marioCharacter.getBounds().contains(opponent.getBounds().x + (opponent.getBounds().width -5), opponent.getBounds().y)) ){
        opponentdie = true;
      } else if (nottouched == true) {
      text_fail.setVisible(true);
      timer_update.stop();
      opponent_jump.stop();    
      opponentleft.stop();
      }
    }
  }

  public void opponentdie(){
    if (opponentdie == true) {
      nottouched = !true;
      opponent.setBounds(opponent.getBounds().x, opponent.getBounds().y +1, opponent.getSize().width , opponent.getSize().height -1);
    }
    if (opponent.getBounds().height == -2){
      opponentdie = false;
      nottouched = true;
      opponent.setBounds(1500, 575, opponentwidth, opponentheight);
    }
  }
    
  public void chek_for_finishline_ActionPerformed(ActionEvent evt) {
    if (marioCharacter.getBounds().intersects(flag.getBounds())) {
      flagtouched = true;
      text_win.setVisible(true);
      timer_update.stop();
      opponent_jump.stop();    
      opponentleft.stop(); 
    } // end of if
    if (flagtouched == true){
      if(this.contactwithground_top() != true){
      marioCharacter.setBounds(marioCharacter.getBounds().x, marioCharacter.getBounds().y +1, marioCharacter.getBounds().width, marioCharacter.getBounds().height);
      flag.setBounds(flag.getBounds().x, flag.getBounds().y +1, flag.getBounds().width, flag.getBounds().height);
      }
    }
  
  } // end of chek_for_finishline_ActionPerformed

  private void loadBuffedImages(){
    
  //Es wird versucht die BufferedImages zu laden
    try {
      boxImage = ImageIO.read((getClass().getResourceAsStream("box.jpg")));
      eventBoxImage = ImageIO.read((getClass().getResourceAsStream("eventBox.jpg")));
      testImage = new ImageIcon(getClass().getResource("eventBox.jpg")).getImage();
    } catch(Exception e) {
      System.out.println(e.toString());
    }
  }
  
  
  private void paintLabels(){
    //Graphics werden geladen und zeichnen ein Bild
    
    //BoxGraphics = box.getGraphics();
    eventBoxGraphics = eventBox.getGraphics();
    //BoxGraphics.drawImage(boxImage,0,0,this);
    eventBoxGraphics.drawImage(testImage,0,0,this);
    
    //Die Graphics der Labels werden auf die Graphic gesetzt
    //eventBox.paint(eventBoxGraphics);
  }
  // Ende Methoden
}
    
    
    
        
    
  
  
  
  
  
  
  
  
  
  
  

